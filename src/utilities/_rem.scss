/**
 * Mixin converting pixel values to REM with pixel fallback.
 * Usage:
 * h1 {
 *   @include rem(marign, 0 auto 20px);
 * }
 * will convert to:
 * h1 {
 *   marign: 0 auto 20px;
 *   marign: 0 auto 1.42857rem;
 * }
 */
@mixin rem( $property, $values ) {
  // Create a couple of empty lists as output buffers.
  $px-values: ();
  $rem-values: ();

  // Loop through the $values list
  @each $value in $values {
    // For each property value, if it's in rem or px, derive both rem and
    // px values for it and add those to the end of the appropriate buffer.
    // Ensure all pixel values are rounded to the nearest pixel.
    @if $value == 0 or $value == 0px {
      // 0 -- use it without a unit
      $px-values: join( $px-values, 0 );
      $rem-values: join( $rem-values, 0 );
    } @else if type-of( $value ) == number and ( unit( $value ) == px ) {
      // px value given - calculate rem value from base-font-size
      $new-rem-value: $value / $base-font-size;
      $px-values: join( $px-values, round( $value ) );
      $rem-values: join( $rem-values, #{$new-rem-value}rem );
    } @else {
      // unitless value - use those directly as rem and calculate the px-fallback
      $px-values: join( $px-values, $value );
      $rem-values: join( $rem-values, $value );
    }
  }

  // output the converted rules
  #{$property}: $px-values;
  #{$property}: $rem-values;
}